<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="./feed.xml" rel="self" type="application/atom+xml" /><link href="./" rel="alternate" type="text/html" /><updated>2021-05-20T18:49:34+00:00</updated><id>./feed.xml</id><title type="html">Blog de Tokiotas</title><subtitle>El viaje m√°s largo comienza con un primer paso.</subtitle><entry><title type="html">Hybrid File Server</title><link href="./2021/06/21/Hybrid_file_server/" rel="alternate" type="text/html" title="Hybrid File Server" /><published>2021-06-21T03:00:00+00:00</published><updated>2021-06-21T03:00:00+00:00</updated><id>./2021/06/21/Hybrid_file_server</id><content type="html" xml:base="./2021/06/21/Hybrid_file_server/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/06/21-hybrid-fil-server/diff_hybrid_file_server.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/06/21-hybrid-fil-server/diff_hybrid_file_server.jpg&quot; style=&quot;&quot; alt=&quot;Hybrid file Server&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;La acumulaci√≥n de archivos y documentos en nuestros servidores de ficheros puede ser preocupante, pues implica la necesidad de eliminar o archivar documentos para liberar espacio y/o ampliar cabina/discos. Esto se suele traducir en malestar por parte del usuario y/o en un desembolso econ√≥mico. Todo ello sin contar con la infraestructura a montar en el caso de tener diferentes sedes en diferentes lugares geogr√°ficos ni tampoco en las soluciones de &lt;em&gt;backup&lt;/em&gt; a implementar.&lt;/p&gt;

&lt;p&gt;Es cierto que existen diferentes tipos de infraestructuras para solucionar estos problemas. Desde Tokiota presentamos una soluci√≥n para solventarlos y, adem√°s, tener una recuperaci√≥n ante un desastre de nuestros servidores de ficheros r√°pido y sencillo. Nosotros la hemos llamado &lt;em&gt;Hybrid File Server&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Utilizamos el concepto de &lt;em&gt;Hybrid File&lt;/em&gt; Server al hecho de centralizar los datos de un servidor de ficheros en un servicio de almacenaje en Azure y tener en nuestra infraestructura &lt;em&gt;On Premise&lt;/em&gt; uno o varios servidores de ficheros con el objetivo de utilizarlo/s como cache de archivos.&lt;/p&gt;

&lt;p&gt;Este sistema consiste en guardar la totalidad de nuestros archivos en una cuenta de almacenamiento de Azure y tener un subconjunto de los documentos vivos, los m√°s utilizados, en el servidor o servidores de ficheros estableciendo una sincronizaci√≥n activa y bidireccional. Esta sincronizaci√≥n puede realizarse con un total de 30 servidores de ficheros distintos.&lt;/p&gt;

&lt;p&gt;Al utilizar la pol√≠tica de nube por niveles (&lt;em&gt;cloud tiering policy&lt;/em&gt;), el espacio ocupado en nuestra infraestructura On Premise por el servidor de ficheros podr√° verse reducido en un 50%, un 60% o incluso un 90%. El funcionamiento de esta pol√≠tica consiste en generar punteros de los documentos menos usados de nuestro servidor de ficheros. Estos punteros contendr√°n los metadatos del fichero y un enlace a nuestro fichero en Azure. En el momento de abrir el puntero, el fichero se descargar√° autom√°ticamente en nuestro servidor de ficheros ocupando as√≠ la totalidad del tama√±o del fichero y pudiendo ser utilizado por el usuario.&lt;/p&gt;

&lt;p&gt;La arquitectura descrita es completamente transparente al usuario a nivel operacional, aunque s√≠ que el usuario podr√° detectar si un archivo est√° vivo o es un puntero.&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/06/21-hybrid-fil-server/diff_hybrid_file_server.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/06/21-hybrid-fil-server/diff_hybrid_file_server.jpg&quot; style=&quot;&quot; alt=&quot;Carpeta con/sin Hybrid File Server configurado&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Los usuarios experimentaran un peque√±o retraso en el primer acceso al puntero, esta acci√≥n descargar√° la totalidad del fichero. A partir de este momento, el fichero pasar√° a ser un documento vivo, si no se vuelve a acceder al documento, se volver√° a transformar en puntero.&lt;/p&gt;

&lt;p&gt;En Azure Storage se mantendr√° la totalidad de los ficheros, pudiendo as√≠ delegar la copia de seguridad del servidor de ficheros a Azure. Esta copia de seguridad puede ser programada y gestionada desde el portal de Azure, sin la necesidad de ninguna herramienta de terceros ni preocuparse por el tiempo de copia. Las opciones de recuperaci√≥n permiten la recuperaci√≥n granular, llegando a nivel de ficheros.&lt;/p&gt;

&lt;p&gt;La recuperaci√≥n ante desastres es uno de los puntos m√°s fuertes de esta arquitectura. En el supuesto que el servidor de ficheros quedase inoperativo, independientemente del problema, la recuperaci√≥n de este servicio es r√°pida y sencilla. √önicamente se tendr√° que desplegar un nuevo servidor de ficheros, habilitar la sincronizaci√≥n con Azure y el servicio estar√° reestablecido. Con esta soluci√≥n no es necesario la recuperaci√≥n del servidor de ficheros de una copia de seguridad, lo que implica un gran ahorro de tiempo y esfuerzo.&lt;/p&gt;

&lt;p&gt;As√≠ de eficiente puede llegar a ser la soluci√≥n de &lt;em&gt;Hybrid File Server&lt;/em&gt;, ofreciendo grandes mejoras y facilitando la gesti√≥n de nuestro servidor de ficheros.&lt;/p&gt;</content><author><name>Daniel Camacho Rodr√≠guez</name></author><category term="hybrid" /><category term="fileserver" /><category term="azure" /><summary type="html">Os traemos nuevo art√≠culo donde conocer la soluci√≥n Hybrid File Server. Olv√≠date de liberar espacio en tus servidores constantemente y de preocuparte por los backups, que Azure se encargue.</summary></entry><entry><title type="html">Sacando provecho de Swagger - parte 3</title><link href="./2021/05/25/MejorasSwaggerParte3/" rel="alternate" type="text/html" title="Sacando provecho de Swagger - parte 3" /><published>2021-05-25T03:00:00+00:00</published><updated>2021-05-25T03:00:00+00:00</updated><id>./2021/05/25/MejorasSwaggerParte3</id><content type="html" xml:base="./2021/05/25/MejorasSwaggerParte3/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/05/25-Mejoras-Swagger-Parte3/swagger-banner.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/05/25-Mejoras-Swagger-Parte3/swagger-banner.png&quot; style=&quot;&quot; alt=&quot;Mejoras Swagger parte 1&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Ya tenemos el tercer post de la serie, ya hemos visto comentarios XML y los ISchemaFilter. Hoy veremos content-type y headers.&lt;/p&gt;

&lt;p&gt;Recordamos que tenemos una API en asp.net core 3.1 y con la versi√≥n de Swashbuckle.AspNetCore 5.0.0.&lt;/p&gt;

&lt;h3 id=&quot;fijar-content-type-applicationjson&quot;&gt;&lt;strong&gt;Fijar content type application/json&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Si nuestra API solo va a aceptar y devolver contenido de tipo json, es recomendar fijar estos par√°metros. Para ello utilizamos los atributos ‚ÄòConsumes‚Äô y ‚ÄòProduces‚Äô de Microsoft.AspNetCore.Mvc.&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
    /// &lt;summary&gt;
    /// Get example info.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot; /&gt;Example id.&amp;lt;/param&amp;gt;
    /// &lt;param name=&quot;request&quot; /&gt;Request example&amp;lt;/param&amp;gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    [HttpPatch(&quot;/example/{id}&quot;)]
    [Consumes(&quot;application/json&quot;)]
    [Produces(&quot;application/json&quot;)]
    public ActionResult&amp;lt; ExampleResponse &amp;gt; GetExample(int id, [FromBody] ExampleRequest request) 
    =&amp;gt; Ok(new ExampleResponse());
&lt;/pre&gt;

&lt;p&gt;En este caso se han aplicado a nivel de m√©todo como caso de prueba, ser√≠a m√°s habitual aplicarlos a toda la API.&lt;/p&gt;

&lt;h3 id=&quot;a√±adir-headers-personalizados&quot;&gt;&lt;strong&gt;A√±adir Headers personalizados&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;En ocasiones tenemos que construir una API que tiene que contar con un header propio, en este caso hemos utilizado un IOperationFilter y lo aplicamos a todos los endpoints.&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
public class CustomHeaderFilter : IOperationFilter
{
    public void Apply(OpenApiOperation operation, OperationFilterContext context)
    {
        if (operation.Parameters == null)
            operation.Parameters = new List&amp;lt; OpenApiParameter &amp;gt;();

        operation.Parameters.Add(new OpenApiParameter
        {
            Name = &quot;x-header&quot;,
            In = ParameterLocation.Header,
            Description = &quot;Custom header for our application.&quot;,
            Required = true,
            Schema = new OpenApiSchema
            {
                Type = &quot;string&quot;,
                Example = new OpenApiString(CustomHeader.Xyz.ToString()),
                Enum = Enum
                    .GetValues(typeof(CustomHeader))
                    .Cast&amp;lt; CustomHeader &amp;gt;()
                        .Select(x =&amp;gt; OpenApiAnyFactory.CreateFor(new OpenApiSchema() { Type = &quot;string&quot; }, x.ToString()))
                        .ToList()
            }
        });
    }
}
&lt;/pre&gt;

&lt;p&gt;Para guardar los valores del CustomHeader se ha utilizado un enum:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
public enum CustomHeader
{
    Xyz,
    Abc
}
&lt;/pre&gt;

&lt;p&gt;Y ya que tenemos un Enum, podemos ajustar NewtonsoftJson para serializar los enums como string. Para ello desde el Startup, en el m√©todo ConfigureServices podemos a√±adir:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
services
    .AddControllers()
    .AddNewtonsoftJson(options =&amp;gt;
    {
        options.SerializerSettings.Converters.Add(new StringEnumConverter());
    });
&lt;/pre&gt;

&lt;p&gt;Una vez creado el IOperationFilter, igual que el resto de filtros de swagger, es necesario registraro como hemos hecho con el filtro anterior:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
services.AddSwaggerGen(c =&amp;gt;
{
    //[...]

    c.OperationFilter&amp;lt; CustomHeaderFilter &amp;gt;();

    //[...]
});
&lt;/pre&gt;

&lt;p&gt;De esta forma, cuando swagger se encuentre el enum de CustomHeader nos facilitar√° un desplegable con los distintos valores:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/05/25-Mejoras-Swagger-Parte3/despValores1.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/05/25-Mejoras-Swagger-Parte3/despValores1.png&quot; style=&quot;&quot; alt=&quot;imagen despValores1&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/05/25-Mejoras-Swagger-Parte3/despValores2.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/05/25-Mejoras-Swagger-Parte3/despValores2.png&quot; style=&quot;&quot; alt=&quot;imagen despValores2&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Muchas gracias. Nos leemos en m√°s art√≠culos.&lt;/p&gt;</content><author><name>Antonio C√°rdenas Garc√≠a</name></author><category term="swagger" /><category term="aspnet" /><category term="netcore" /><summary type="html">3¬™ parte de la serie de art√≠culos dedicados a Swagger. A√±adiendo Headers personalizados sobre una api en NetCore.</summary></entry><entry><title type="html">Azure CLI, documenta todo lo que no pudiste</title><link href="./2021/05/10/Azure-CLI/" rel="alternate" type="text/html" title="Azure CLI, documenta todo lo que no pudiste" /><published>2021-05-10T03:00:00+00:00</published><updated>2021-05-10T03:00:00+00:00</updated><id>./2021/05/10/Azure-CLI</id><content type="html" xml:base="./2021/05/10/Azure-CLI/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/05/10-Azure-CLI/logo.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/05/10-Azure-CLI/logo.png&quot; style=&quot;&quot; alt=&quot;Azure CLI&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;El entorno gr√°fico del portal de Azure, cambia constantemente.&lt;/p&gt;

&lt;p&gt;Documentar peque√±os cambios que no has podido implementar en la IaC y se realiza de forma manual, suele ser algo que se olvida documentar en los proyectos y provoca m√°s de un quebradero de cabeza.&lt;/p&gt;

&lt;p&gt;Supongamos que en nuestra organizaci√≥n se hacen las cosas bien y usamos la wiki del proyecto, pero nos dedicamos a poner capturas de imagen de lo que tenemos que hacer y en dos meses debemos volver a esta documentaci√≥n. Tras esos dos meses el entorno gr√°fico de Azure habr√° cambiado, la opci√≥n que buscabas no las encuentras donde pon√≠a la captura, suele ocurrir que la cambian de nombre o reorganizan los men√∫s; el caso es que la documentaci√≥n gr√°fica &lt;strong&gt;no&lt;/strong&gt; nos ayuda, es obsoleta y solo se han puesto capturas con muy poco texto, en muchos casos ninguno, ¬øqu√© quer√≠amos hacer?, ¬øqu√© es lo que pretend√≠a decirme la imagen?, ‚Ä¶&lt;/p&gt;

&lt;p&gt;Para que esto no suceda y &lt;strong&gt;para que siempre tengamos todo documentado de la mejor forma, es recomendable usar un comando de CLI&lt;/strong&gt;.&lt;/p&gt;

&lt;div class=&quot;note note&quot;&gt;
    &lt;span class=&quot;notetitle&quot;&gt;
        
        Nota:
        
    &lt;/span&gt; 
Si ni siquiera estas usando capturas de pantalla para documentar. Es un consejo, comienza a documentar esos peque√±os cambios, y ya que comienzas a hacerlo, comienza bien: usa comandos CLI.
&lt;/div&gt;

&lt;p&gt;Tienes 3 opciones para realizar acciones con comandos en Azure:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Azure Cloud Shell.&lt;/li&gt;
  &lt;li&gt;M√≥dulo de Powershell.&lt;/li&gt;
  &lt;li&gt;Azure CLI.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;¬øCu√°l de ellos es recomendable usar? depende. Lo recomendable es usar siempre el recomendado en tu organizaci√≥n y como consultores, en unos sitios ser√° el modulo de Powershell y en otras me permitir√°n usar el portal de Azure, por tanto Azure Cloud Shell. Y si tubiera que usar siempre uno, naturalmente (Azure CLI)[https://docs.microsoft.com/es-es/cli/azure/install-azure-cli].&lt;/p&gt;

&lt;p&gt;Por ejemplo para ver los datos de una cuenta en Powershell y Azure CLI:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;Powerhsell&quot;&gt;  
//Example with Powershell
Get-AzSubscription

//Example with Azure CLI
az account show
&lt;/pre&gt;

&lt;p&gt;Sea cual sea tu situaci√≥n, evita capturar im√°genes en nuestra documentaci√≥n. Un simple comando nos permitir√° ser conciso.&lt;/p&gt;

&lt;p&gt;Por ejemplo, imaginemos que debemos activar en una Azure Function la configuraci√≥n &lt;em&gt;Allways on&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Una captura cuidad para documentaci√≥n ser√≠a:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/05/10-Azure-CLI/Img01.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/05/10-Azure-CLI/Img01.png&quot; style=&quot;&quot; alt=&quot;Captura con una herramienta m√°s profesional&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Y si eres buen documentador habr√°s puesto el nombre de la funci√≥n, como acceder al men√∫, capturar la imagen de lo que debes cambiar y por supuesto habr√°s usado una buena resoluci√≥n de la captura para que se vea bien. Aunque esta imagen ya es capad de documentar por s√≠ misma.&lt;/p&gt;

&lt;p&gt;Pero lo habitual es esto:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/05/10-Azure-CLI/Img02.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/05/10-Azure-CLI/Img02.png&quot; style=&quot;&quot; alt=&quot;Captura con una herramienta como MS Paint&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;La primera captura, supone tener una herramienta de pago que permite hacer buenas capturas de documentaci√≥n y no es habitual disponer de ella.&lt;/p&gt;

&lt;p&gt;En la primera relativamente he tardado poco en hacerlo en la segunda mucho m√°s tiempo, he usado MS Paint. En ambas he tenido que hacer muchas cosas, frente a una l√≠nea de comando:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;Powerhsell&quot;&gt;  
az functionapp config set --always-on true --name MyFunctionApp 
   --resource-group MyResourceGroup
&lt;/pre&gt;

&lt;p&gt;Como puedes observar, no tiene comparaci√≥n. M√°xime cuando los comandos no cambian, se ampl√≠an con funcionalidades, pero no cambian.&lt;/p&gt;

&lt;p&gt;Espero que esta peque√±a reflexi√≥n te ayude a mejorar la documentaci√≥n de tu proyecto de Azure y por qu√© no en aquellas acciones que puedas usar este paradigma.&lt;/p&gt;</content><author><name>Jose Mar√≠a Flores Zazo</name></author><category term="iac" /><category term="cli" /><category term="azure" /><summary type="html">La documentaci√≥n es un punto muy importante de tu trabajo, m√°xime en un entorno como Azure. Usar Azure CLI es una forma optima para documentar, veamos por qu√©.</summary></entry><entry><title type="html">Sacando provecho de Swagger - parte 2</title><link href="./2021/04/26/MejorasSwaggerParte2/" rel="alternate" type="text/html" title="Sacando provecho de Swagger - parte 2" /><published>2021-04-26T03:00:00+00:00</published><updated>2021-04-26T03:00:00+00:00</updated><id>./2021/04/26/MejorasSwaggerParte2</id><content type="html" xml:base="./2021/04/26/MejorasSwaggerParte2/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/26-Mejoras-Swagger-Parte2/swagger-banner.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/26-Mejoras-Swagger-Parte2/swagger-banner.png&quot; style=&quot;&quot; alt=&quot;Mejoras Swagger parte 1&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Continuamos con el segundo post de la serie enfocada a sacar m√°s provecho a Swagger y darle m√°s valor a nuestra API.&lt;/p&gt;

&lt;p&gt;En el primer post vimos como a√±adir comentarios XML y hoy veremos como a√±adir ejemplos a los esquemas.&lt;/p&gt;

&lt;p&gt;Recordamos que tenemos una API en asp.net core 3.1 y con la versi√≥n de Swashbuckle.AspNetCore 5.0.0.&lt;/p&gt;

&lt;h3 id=&quot;a√±adir-ejemplos-para-los-esquemas&quot;&gt;&lt;strong&gt;¬øA√±adir ejemplos para los esquemas?&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;Si a√±adimos ejemplos a los esquemas que tenemos mejoraremos mucho la usabilidad de los endpoints y ayudaremos a la interpretaci√≥n de las respuestas.&lt;/p&gt;

&lt;p&gt;Para ello hay varias formas, yo me he decantado por utilizar ISchemaFilter de forma que para cada esquema le a√±adimos un ejemplo predefinido:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
public class ExampleSchemaFilter : ISchemaFilter
{
    public void Apply(OpenApiSchema schema, SchemaFilterContext context) =&amp;gt; schema.Example = GetExampleOrNullFor(context.Type);

    private IOpenApiAny GetExampleOrNullFor(Type type)
    {
        switch (type.Name)
        {
            case nameof(ExampleRequest):
                return new OpenApiObject
                {
                    [ExampleRequest.ElementJsonProperty] = new OpenApiString(&quot;Some element request.&quot;)
                };
            case nameof(ExampleResponse):
                return new OpenApiObject
                {
                    [ExampleResponse.ResponseJsonProperty] = new OpenApiString(&quot;Any response.&quot;),
                    [ExampleResponse.ErrorsJsonProperty] = new OpenApiNull()
                };
            default:
                return null;
        }
    }
}
&lt;/pre&gt;

&lt;p&gt;Para acabar de entender el ejemplo muestro las clases de Request y Response utilizadas:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
public class ExampleRequest
{
    public const string ElementJsonProperty = &quot;element_json_custom_name&quot;;

    [JsonProperty(PropertyName = ElementJsonProperty, Required = Required.Always)]
    [StringLength(200, MinimumLength = 5)]
    public string Element { get; set; }
}
public class ExampleResponse
{
    public const string ResponseJsonProperty = &quot;response_json_custom_name&quot;;
    public const string ErrorsJsonProperty = &quot;errors_json_custom_name&quot;;

    [JsonProperty(PropertyName = ResponseJsonProperty, Required = Required.DisallowNull)]
    [StringLength(300)]
    public string Response { get; set; }

    [JsonProperty(PropertyName = ErrorsJsonProperty, Required = Required.AllowNull)]
    public string Errors { get; set; }
}
&lt;/pre&gt;

&lt;p&gt;En este caso, adem√°s de montar los ejemplos para peticiones y respuestas, he aprovechado para a√±adir ciertos atributos a los campos como el JsonProperty o el StringLenght, estos atributos al igual que otros atributos de Newtonsoft.Json o de System.ComponentModel.DataAnnotations son perfectamente reconocidos por swagger y a√±adir√° las restricciones oportunas.&lt;/p&gt;

&lt;p&gt;En este caso en hemos utilizado el JsonProperty por que nos puede interesar que el nombre del par√°metro del Json sea uno concreto o para indicar si un campo es obligatorio, o si tiene que estar presente en el json pero puede ser nulo entre otros. De la misma forma tambi√©n hemos especificado unos StringLength.&lt;/p&gt;

&lt;p&gt;Centr√°ndonos en el ISchemaFilter, el paquete de Swashbuckle ya se encarga de descubrir los endpoints y leer los par√°metros de entrada y salida, en el ejemplo para cada esquema le asignamos un ejemplo.&lt;/p&gt;

&lt;p&gt;Para que se aplique el scheme tenemos que registrarlo en la configuraci√≥n del swagger:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
services.AddSwaggerGen(c =&amp;gt;
{
    //[...] 

    c.SchemaFilter &amp;lt; ExamplesSchemaFilter &amp;gt;();

    //[...]
});
&lt;/pre&gt;

&lt;p&gt;Ahora al abrir swagger nos aparecer√°n estos ejemplos a√±adidos:&lt;/p&gt;

&lt;p&gt;Creamos el siguiente endpoint de ejemplo:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
/// &lt;summary&gt;
/// Get example info.
/// &lt;/summary&gt;
/// &lt;param name=&quot;id&quot; /&gt;Example id.&amp;lt;/param&amp;gt;
/// &lt;param name=&quot;request&quot; /&gt;Request example&amp;lt;/param&amp;gt;
/// &lt;returns&gt;&lt;/returns&gt;
[HttpPatch(&quot;/example/{id}&quot;)]
[ProducesResponseType(typeof(ExampleResponse), (int)HttpStatusCode.NoContent)]
[ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.BadRequest)]
[ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.Unauthorized)]
[ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.Forbidden)]
[ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.NotFound)]
public ActionResult&amp;lt; ExampleResponse &amp;gt; GetExample(int id, [FromBody] ExampleRequest request) =&amp;gt; Ok(new ExampleResponse());
&lt;/pre&gt;

&lt;p&gt;Y desde swagger veremos los esquemas asociados a Example Request y Response&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/26-Mejoras-Swagger-Parte2/Esquemas.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/26-Mejoras-Swagger-Parte2/Esquemas.png&quot; style=&quot;&quot; alt=&quot;imagen Esquemas&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;</content><author><name>Antonio C√°rdenas Garc√≠a</name></author><category term="swagger" /><category term="aspnet" /><category term="netcore" /><summary type="html">2¬™ de parte de art√≠culos sobre Swagger y a√±adiendo ejemplos a nuestros esquemas</summary></entry><entry><title type="html">Introducci√≥n a Azure Bicep</title><link href="./2021/04/12/IntroduccionAzureBicep/" rel="alternate" type="text/html" title="Introducci√≥n a Azure Bicep" /><published>2021-04-12T03:00:00+00:00</published><updated>2021-04-12T03:00:00+00:00</updated><id>./2021/04/12/IntroduccionAzureBicep</id><content type="html" xml:base="./2021/04/12/IntroduccionAzureBicep/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/logo.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/logo.png&quot; style=&quot;&quot; alt=&quot;Azure Bicep&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;En el momento de la publicaci√≥n de este art√≠culo el desarrollo del producto esta en una fase inicial, pero con soporte por parte de Azure.&lt;/p&gt;

&lt;p&gt;Desde la versi√≥n 0.3.1, los puntos destacables son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Integraci√≥n con Az CLI y Az PS.&lt;/li&gt;
  &lt;li&gt;Deja de ser una herramienta experimental.&lt;/li&gt;
  &lt;li&gt;Compatible con los planes de soporte de Microsoft&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;El prop√≥sito de Azure Bicep el siguiente:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Usar un lenguaje m√°s amigable para un desarrollador que los JSON de ARM.&lt;/li&gt;
  &lt;li&gt;Producir una sola plantilla de ARM para evitar el uso de una cuenta de almacenamiento o cualquier otro sistema para almacenar plantillas vinculadas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A diferencia de &lt;a href=&quot;https://www.terraform.io/&quot;&gt;Terraform&lt;/a&gt; o &lt;a href=&quot;https://www.pulumi.com/&quot;&gt;Pulumi&lt;/a&gt;, Bicep es espec√≠fico de Azure. Podr√≠amos pensar que Microsoft est√°n creando una nueva generaci√≥n de ARM.&lt;/p&gt;

&lt;p&gt;Si ya tienes experiencia con Terraform o con Pulumi, podr√°s observar que el prop√≥sito de Bicep es similar a las ventajas que tenemos con Terraform o Pulumi:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Menor n√∫mero de l√≠neas de c√≥digo necesarias para crear un recurso en Azure que usando ARM.&lt;/li&gt;
  &lt;li&gt;Usan lenguajes o bien propios como Terraform (HCL) o bien el casi m√°s te guste con Pulumi (puedes usar C#, JS, TS, Go ‚Ä¶).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Parece que el prop√≥sito de Bicep es darnos a los desarrolladores una alternativa similar a Terraform o Pulumi nativa de Microsoft.&lt;/p&gt;

&lt;p&gt;El proyecto Biceps est√° en: &lt;a href=&quot;https://github.com/Azure/bicesp&quot; target=&quot;_blank&quot;&gt;https://github.com/Azure/bicesp&lt;/a&gt;, suscr√≠bete para estar al d√≠a.&lt;/p&gt;

&lt;p&gt;Supongo que alguna vez has visto un ARM para generar un recurso de Azure y si no, aqu√≠ tienes un extracto:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img01.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img01.png&quot; style=&quot;&quot; alt=&quot;Ejemplo de ARM&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;¬øQu√© necesitamos para poder hacer un ejemplo pr√°ctico?:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Instalar la herramienta CLI de Bicep (seguir las instrucciones: &lt;a href=&quot;https://github.com/Azure/bicep/blob/main/docs/installing.md&quot;&gt;https://github.com/Azure/bicep/blob/main/docs/installing.md&lt;/a&gt;).&lt;/li&gt;
  &lt;li&gt;Instalar la extensi√≥n de Visual Studio Code para Bicep. Es un paso opcional, pero mejora mucho nuestro trabajo con Bicep.&lt;/li&gt;
  &lt;li&gt;Abrir el fichero bicep disponible en el repot de GitHub.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img02.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img02.png&quot; style=&quot;&quot; alt=&quot;Ejemplo de Bicep&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;En el ejemplo anterior, donde creamos una Web App, para ARM usamos 68 l√≠neas mientras que para Bicep solamente estamos en 31 l√≠neas Es &lt;strong&gt;m√°s conciso&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Podr√°s observar que la Web App no necesita que se declare expl√≠citamente la dependencia con el Service Plan, basta con usar plan.id para inferir la dependencia. &lt;strong&gt;Es m√°s legible&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Por desgracia, aun no existe una integraci√≥n oficial de Bicep con Azure DevOps (solo algunas cosas experimentales). Pero todo hace pensar que seguir√° la logica que se est√° aplicando con Terraform o Pulumi, ya que los comandos son muy parecidos a lo que ejecutan ambos sistemas:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img03.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img03.png&quot; style=&quot;&quot; alt=&quot;Ejemplo de Terraform&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Por tanto vamos a usar de momento Bicep para crear un fichero &lt;em&gt;.json&lt;/em&gt; de ARM a partir de un fichero &lt;em&gt;.bicep&lt;/em&gt;:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img04.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img04.png&quot; style=&quot;&quot; alt=&quot;De Bicep a ARM&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Tras la ejecuci√≥n de la build ya tendremos una plantilla de ARM:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img05.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img05.png&quot; style=&quot;&quot; alt=&quot;Salida de la build de Bicep en ARM&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Con esta plantilla podemos probar nuestro ejemplo usando &lt;strong&gt;Azure CLI&lt;/strong&gt; desde el terminal de VS Code:&lt;/p&gt;

&lt;div class=&quot;note note&quot;&gt;
    &lt;span class=&quot;notetitle&quot;&gt;
        
        Nota:
        
    &lt;/span&gt; 
Usar --confirm-with-what-if exige tener la √∫ltima versi√≥n de Azure CLI, puedes optar a probar el ARM desde DevOps, por ejemplo.
&lt;/div&gt;

&lt;pre data-enlighter-language=&quot;Powerhsell&quot;&gt;  
az deployment group create --resource-group 'tokiotajmfztest'
   --template-file main.json --confirm-with-what-if
&lt;/pre&gt;

&lt;p&gt;Generando como resultado:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img06.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/04/12-Introduccion-Azure-Bicep/img06.png&quot; style=&quot;&quot; alt=&quot;Salida de la build de Bicep en ARM&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Solo te faltar√≠a escribir &lt;em&gt;y&lt;/em&gt; para desplegar la infraestructura.&lt;/p&gt;

&lt;p&gt;Como podr√° haber visto es m√°s sencillo, f√°cil de leer y es nativo para Azure. Podr√≠a decirse que Bicep es el sucesor nativo de ARM. No pierdas de vista esta herramienta.&lt;/p&gt;</content><author><name>Jose Mar√≠a Flores Zazo</name></author><category term="iac" /><category term="arm" /><category term="bicep" /><category term="azure" /><summary type="html">Azure ARM tiene sucesor y se llama Bicep. Descubre por qu√©.</summary></entry><entry><title type="html">Sacando provecho de Swagger - parte 1</title><link href="./2021/03/29/MejorasSwaggerParte1/" rel="alternate" type="text/html" title="Sacando provecho de Swagger - parte 1" /><published>2021-03-29T03:00:00+00:00</published><updated>2021-03-29T03:00:00+00:00</updated><id>./2021/03/29/MejorasSwaggerParte1</id><content type="html" xml:base="./2021/03/29/MejorasSwaggerParte1/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/swagger-banner.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/swagger-banner.png&quot; style=&quot;&quot; alt=&quot;Mejoras Swagger parte 1&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Vamos a empezar una serie de posts dedicados a sacar m√°s provecho a Swagger y darle m√°s valor a nuestra API.&lt;/p&gt;

&lt;p&gt;Una vez hemos creado nuestra API y ya tenemos swagger instalado y funcionando, es buen momento para a√±adir m√°s informaci√≥n y hacerlo m√°s √∫til y usable. En concreto, el ejemplo se ha realizado con Visual Studio 2019, con una API en asp.net core 3.1 y con la versi√≥n de Swashbuckle.AspNetCore 5.0.0.&lt;/p&gt;

&lt;h3 id=&quot;comentarios-xml&quot;&gt;&lt;strong&gt;Comentarios XML&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;El primer paso ser√≠a habilitar los comentarios XML. Esto nos servir√° para a√±adir a cada endpoint informaci√≥n adicional:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
    /// &lt;summary&gt;
    /// Get example info.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot; /&gt;Example id.&amp;lt;/param&amp;gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    [HttpGet(&quot;/example/{id}&quot;)]
    public IActionResult GetExample(int id) =&amp;gt; Ok(id);
&lt;/pre&gt;

&lt;p&gt;Para que se lean y muestren los summaries en swagger primero tenemos que agregar unas l√≠neas en el csproj del projecto de la API:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;xml&quot;&gt;  
  &lt;PropertyGroup&gt;
    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
  &lt;/PropertyGroup&gt;
&lt;/pre&gt;

&lt;p&gt;No obstante, esto nos provocar√° un inc√≥modo warning en cada m√©todo que no tenga summary:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/warning.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/warning.png&quot; style=&quot;&quot; alt=&quot;Imagen warning&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Para que no aparezcan estos warngins los podemos deshabilitar a√±adiendo una l√≠nea m√°s al anterior c√≥digo del PropertyGroup:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;xml&quot;&gt;  
  &lt;PropertyGroup&gt;
    &lt;GenerateDocumentationFile&gt;true&lt;/GenerateDocumentationFile&gt;
    &lt;NoWarn&gt;$(NoWarn);1591&lt;/NoWarn&gt;
  &lt;/PropertyGroup&gt;
&lt;/pre&gt;

&lt;p&gt;Ahora que hemos configurado la generaci√≥n de los xml, tenemos que a√±adirlos en la configuraci√≥n del swagger.&lt;/p&gt;

&lt;p&gt;Para ello, en el Startup al configurar AddSwaggerGen a√±adiremos las siguientes l√≠neas:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
services.AddSwaggerGen(c =&amp;gt;
{
    //[...]
    
    var xmlFile = $&quot;{Assembly.GetExecutingAssembly().GetName().Name}.xml&quot;;
    var xmlPath = Path.Combine(AppContext.BaseDirectory, xmlFile);
    c.IncludeXmlComments(xmlPath);
    
    //[...]
});
&lt;/pre&gt;

&lt;p&gt;De esta forma, nos aparecer√° est√° informaci√≥n cuando vayamos a llamar al endpoint en cuesti√≥n:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/InfoEndpoint.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/InfoEndpoint.png&quot; style=&quot;&quot; alt=&quot;Imagen InfoEndpoint&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;En este punto, es interesante aprovechar para especificar las respuestas de dicho endpoint. Para ello podemos utilizar el atributo ProducesResponseTypeAttribute especificando los HttpStatusCodes que devolvemos. Adicionalmente, tambi√©n se puede especificar un mensaje concreto para cada c√≥digo de respuesta a√±adiendo tags ‚Äòresponse‚Äô en el summary:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;csharp&quot;&gt;  
    /// &lt;summary&gt;
    /// Get example info.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;id&quot; /&gt;Example id.&amp;lt;/param&amp;gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    /// &lt;response code=&quot;200&quot;&gt;Ok response.&lt;/response&gt;
    /// &lt;response code=&quot;403&quot;&gt;Custom response for 403.&lt;/response&gt;
    [HttpGet(&quot;/example/{id}&quot;)]
    [ProducesResponseType(typeof(int), (int)HttpStatusCode.OK)]
    [ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.BadRequest)]
    [ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.Unauthorized)]
    [ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.Forbidden)]
    [ProducesResponseType(typeof(ErrorResponse), (int)HttpStatusCode.NotFound)]
    public IActionResult GetExample(int id) =&amp;gt; Ok(id);
&lt;/pre&gt;

&lt;p&gt;Con esto, ahora swagger nos mostrar√°, adem√°s de la response (200 - Success) que hemos visto antes, un ErrorResponse para los c√≥digos 400, 401, 403 y 403. Y en concreto, un mensaje personalizado para el c√≥digo 200 y para el 403. .&lt;/p&gt;

&lt;p&gt;A las respuestas de error, le hemos a√±adido un tipo de respuesta propio (ErrorResponse) no es obligatorio, pero es recomendable.&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/responses.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/29-Mejoras-Swagger-Parte1/responses.png&quot; style=&quot;&quot; alt=&quot;Imagen responses&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;</content><author><name>Antonio C√°rdenas Garc√≠a</name></author><category term="swagger" /><category term="aspnet" /><category term="netcore" /><summary type="html">Sacando el m√°ximo partido a nuestras APIs con Swagger - parte 1</summary></entry><entry><title type="html">Arrancando SQL Server en docker linux</title><link href="./2021/03/15/arrancando-sql-server-docker/" rel="alternate" type="text/html" title="Arrancando SQL Server en docker linux" /><published>2021-03-15T03:00:00+00:00</published><updated>2021-03-15T03:00:00+00:00</updated><id>./2021/03/15/arrancando-sql-server-docker</id><content type="html" xml:base="./2021/03/15/arrancando-sql-server-docker/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/15-arrancando-sql-server-docker/sqlserver_docker_min.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/15-arrancando-sql-server-docker/sqlserver_docker_min.png&quot; style=&quot;&quot; alt=&quot;SQL Server + Docker&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;Si quieres arrancar r√°pidamente un SQL Server lo mejor es usar docker. Y con m√°s raz√≥n si ya tienes WSL2 instalado üòÄ, y si todav√≠a no lo tienes √©chale un vistazo a la &lt;a href=&quot;https://docs.microsoft.com/es-es/windows/wsl/install-win10&quot;&gt;gu√≠a de instalaci√≥n&lt;/a&gt;.
Esto puede resultar muy √∫til para no tener que instalar un entorno completo localmente.
En la &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/linux/quickstart-install-connect-docker?view=sql-server-ver15&amp;amp;pivots=cs1-bash&quot;&gt;documentaci√≥n oficial&lt;/a&gt; tienes toda la info. Yo lo he resumido con algunos cambios aqu√≠:&lt;/p&gt;

&lt;pre data-enlighter-language=&quot;bash&quot;&gt;
docker run 
  --name sql1 
  -h sql1 
  -e 'ACCEPT_EULA=Y' 
  -e 'SA_PASSWORD=MiPa$$w0rd' 
  -e 'MSSQL_PID=Enterprise' 
  -p 11433:1433 
  -d 
  mcr.microsoft.com/mssql/server:2019-latest
&lt;/pre&gt;

&lt;p&gt;Yo ya ten√≠a el puerto 1433 ocupado en mi m√°quina por lo que he mapeado la imagen al puerto 11433.&lt;/p&gt;

&lt;p&gt;Para conectarte usando el Management Studio:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Server: 127.0.0.1,11433  (el puerto se indica separando con una coma)&lt;/li&gt;
  &lt;li&gt;User: SA&lt;/li&gt;
  &lt;li&gt;Password: la que hay√°is indicado al arrancar el contenedor.&lt;/li&gt;
  &lt;li&gt;Vamos a Options y en la &lt;em&gt;Additional Connection Parameters&lt;/em&gt; debemos a√±adir &lt;code class=&quot;highlighter-rouge&quot;&gt;TrustServerCertificate=True&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/15-arrancando-sql-server-docker/mmssqlserver_connections.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/15-arrancando-sql-server-docker/mmssqlserver_connections.png&quot; style=&quot;&quot; alt=&quot;Instrucciones para conectar Management Studio&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Todo funcionando.&lt;/p&gt;

&lt;p&gt;Ahora cuando no lo necesites puedes detener el contenedor con &lt;code class=&quot;highlighter-rouge&quot;&gt;docker stop sql1&lt;/code&gt; de esta manera no te consume recursos de la m√°quina. 
&lt;br /&gt;Y lo arrancas con &lt;code class=&quot;highlighter-rouge&quot;&gt;docker start sql1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;F√°cil y sencillo.&lt;/p&gt;

&lt;p&gt;Happy codding!&lt;/p&gt;</content><author><name>David Gonzalo</name></author><category term="docker" /><category term="sqlserver" /><category term="linux" /><summary type="html">Arrancando SQLServer en docker linux para nuestro entorno desarrollo.</summary></entry><entry><title type="html">Qu√© es Swagger y c√≥mo a√±adirlo a tu Api de NetCore</title><link href="./2021/03/01/Add-Swagger-To-Net-Core-Api/" rel="alternate" type="text/html" title="Qu√© es Swagger y c√≥mo a√±adirlo a tu Api de NetCore" /><published>2021-03-01T03:01:00+00:00</published><updated>2021-03-01T03:01:00+00:00</updated><id>./2021/03/01/Add%20Swagger%20To%20Net%20Core%20Api</id><content type="html" xml:base="./2021/03/01/Add-Swagger-To-Net-Core-Api/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/swaggerandcore.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/swaggerandcore.jpg&quot; style=&quot;&quot; alt=&quot;Add Swagger to Net Core Api&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;h3 id=&quot;qu√©-es-swagger&quot;&gt;¬øQu√© es swagger?&lt;/h3&gt;

&lt;p&gt;Swagger es una serie de reglas, especificaciones y herramientas que nos ayudan a documentar nuestras APIs. En otras palabras, al instalarlo, y ejecutar la API se nos generar√° una interfaz de usuario que nos permite navegar sobre los diferentes endpoints que tenga nuestra API de manera f√°cil e intuitiva. Es una herramienta muy √∫til a la hora de testear nuestras aplicaciones.&lt;/p&gt;

&lt;h3 id=&quot;c√≥mo-lo-usamos&quot;&gt;¬øC√≥mo lo usamos?&lt;/h3&gt;
&lt;p&gt;Para utilizar swagger lo primero que debemos hacer es instalarlo, obviamente.&lt;/p&gt;

&lt;p&gt;Vamos al gestor de Nuget de nuestra API (Manage Nuget Packages) y buscamos el nuget Swashbuckle.AspNetCore:&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/nuget.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/nuget.png&quot; style=&quot;&quot; alt=&quot;Imagen nuget&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Lo siguiente que debemos hacer es registrar el servicio de swagger en nuestra ServiceCollection (clase Startup.cs, m√©todo ConfigureServices) a√±adiendo √©stas l√≠neas.&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/registerService.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/registerService.png&quot; style=&quot;&quot; alt=&quot;Imagen register service&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Tambi√©n tendremos que a√±adir una breve configuraci√≥n (clase Startup, m√©todo Configure) para indicar la ruta donde se ejecutar√° el swagger, as√≠ como tambi√©n un nombre para la documentaci√≥n que se nos va a generar.&lt;/p&gt;

&lt;p&gt;En mi caso quiero que se ejecute en el directorio ra√≠z de la aplicaci√≥n y por lo tanto configurar√© la propiedad RoutePrefix como cadena vac√≠a.&lt;/p&gt;

&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/configure.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/configure.png&quot; style=&quot;&quot; alt=&quot;Imagen configure&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Llegados a este punto ya podemos ejecutar nuestra API y comprobar lo de lo que es capaz nuestro asistente para documentaci√≥n y testing.&lt;/p&gt;

&lt;p&gt;En las siguientes im√°genes podemos ver un ejemplo paso a paso:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vista preliminar:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/ej1.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/ej1.png&quot; style=&quot;&quot; alt=&quot;Imagen ejemplo1&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;M√©todo Get Simple:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/ej2.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/ej2.png&quot; style=&quot;&quot; alt=&quot;Imagen ejemplo2&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;M√©todo Post con asistente de creaci√≥n del objeto:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/ej3.png&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Add-Swagger-To-Net-Core-Api/ej3.png&quot; style=&quot;&quot; alt=&quot;Imagen ejemplo3&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;F√°cil y sencillo. 
&lt;br /&gt;Hasta la pr√≥xima.&lt;/p&gt;</content><author><name>Francisco Javier Lafuente</name></author><category term="swagger" /><category term="netcore" /><category term="api" /><summary type="html">Qu√© es Swagger y c√≥mo a√±adir a tu Api de NetCore esta fant√°stica herramienta.</summary></entry><entry><title type="html">Hello world!</title><link href="./2021/03/01/Hello-World/" rel="alternate" type="text/html" title="Hello world!" /><published>2021-03-01T03:00:00+00:00</published><updated>2021-03-01T03:00:00+00:00</updated><id>./2021/03/01/Hello-World</id><content type="html" xml:base="./2021/03/01/Hello-World/">&lt;div class=&quot;containerImgs&quot;&gt;
  &lt;a href=&quot;./public/uploads/2021/03/01-Hello-World/hello-toris.jpg&quot; target=&quot;_blank&quot;&gt;
    &lt;img src=&quot;./public/uploads/2021/03/01-Hello-World/hello-toris.jpg&quot; style=&quot;&quot; alt=&quot;Hello World!&quot; /&gt;
  &lt;/a&gt;
&lt;/div&gt;

&lt;p&gt;Hello World!&lt;/p&gt;

&lt;p&gt;Con estas palabras, y su significado desde los inicios del mundo de la programaci√≥n, comenzamos este nuevo rinc√≥n en donde compartir nuestras inquietudes tecnol√≥gicas, englobado al mundo del desarrollo de software, infraestructura, cloud, web, m√≥vil, innovaci√≥n‚Ä¶&lt;/p&gt;

&lt;p&gt;Un rinc√≥n creado con la pasi√≥n de todos nuestros tokiotas por compartir el conocimiento.&lt;/p&gt;

&lt;p&gt;Gracias.
&lt;br /&gt;„ÅÇ„Çä„Åå„Å®„ÅÜ„ÄÇ&lt;/p&gt;</content><author><name>Tokiota</name></author><category term="azure" /><category term="microsoft" /><summary type="html">Arrancamos nuevo blog. Un rinc√≥n creado con la pasi√≥n de todos nuestros Tokiotas por compartir el conocimiento.</summary></entry></feed>